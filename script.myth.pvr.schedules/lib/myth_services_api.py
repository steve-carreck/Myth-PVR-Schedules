# encoding=utf-8
#                Copyright 2015 - 2020 Steven Carreck
#                    GNU GENERAL PUBLIC LICENSE
#                       Version 3, 29 June 2007
#     This file is part of Myth PVR Schedules.
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.

__author__ = 'Steven Carreck'

import urllib2  # http://www.pythonforbeginners.com/python-on-the-web/how-to-use-urllib2-in-python/
from urllib2 import URLError  # For url request errors
import urllib
from datetime import datetime  # https://docs.python.org/2/library/datetime.html
import time
import json

_date_format = ''                   # Date format to be displayed in UI.
_time_format = ''                   # Time format to be displayed in UI.
_request_size = 10                  # Default HTTP Request chunk/records request size.
_list_index_to_rec_rule_id = {}     # Mapping of UI list item to recording rule id.
_program_overrides = []             # List of recording overrides generated by RecordingRule and used by Programs.
_myth_url_prefix = ''               # Myth server HTTP prefix for http requests.


# API Initialization.
class MythBackendAPI:
    def __init__(self, backend_hostname, backend_port, backend_pin, date_format, time_format, request_size):
        self.__BackEndIP_ = backend_hostname
        self.__BackEndPort_ = backend_port
        self.__BackEndPin_ = backend_pin
        self.__make_url_prefix()

        global _date_format
        _date_format = date_format

        global _time_format
        _time_format = time_format

        global _request_size
        _request_size = int(request_size)

    def __make_url_prefix(self):
        global _myth_url_prefix
        _myth_url_prefix = 'http://' + self.__BackEndIP_ + ':' + self.__BackEndPort_

    def get_myth_version(self):
        """ Returns Myth Backend connection information."""
        http_url = _myth_url_prefix + '/Myth/version'
        class_http_request = HTTPRequest(http_url)
        class_http_request.http_request()
        return class_http_request.HTML

    def get_myth_connection_info(self):
        """ Returns Myth Backend connection information."""
        http_url = _myth_url_prefix + '/Myth/GetConnectionInfo?Pin=' + self.__BackEndPin_
        class_http_request = HTTPRequest(http_url)
        class_http_request.http_request()
        return class_http_request.HTML

    def get_myth_hostname(self):
        """ Returns Myth Backend connection information."""
        http_url = _myth_url_prefix + '/Myth/GetHostName'
        class_http_request = HTTPRequest(http_url)
        class_http_request.http_request()
        return class_http_request.HTML

    def get_myth_pvr_version(self):
        """ Returns Myth Backend connection information."""
        http_url = _myth_url_prefix + '/Dvr/version'
        class_http_request = HTTPRequest(http_url)
        class_http_request.http_request()
        return class_http_request.HTML

    def utf8_percent_decode(self, url_encoded):
        http_utf8_decode = urllib2.unquote(url_encoded.encode("utf8"))
        # http_utf8_decode = urllib.unquote_plus(url_encoded.encode("utf8"))
        return http_utf8_decode

    def split_decode(self, url_decoded):
        str_lines = url_decoded.split('&')
        return str_lines

class ErrorInfo:
    def __init__(self):
        self.Err = False
        self.ErrCodeOrReason = ''
        self.ErrMessage = ''

    def reset(self):
        self.Err = False
        self.ErrCodeOrReason = ''
        self.ErrMessage = ''

class HTTPRequest:
    def __init__(self, url, post_data_dict=None, request_timeout=4):
        self.ErrorInfo = ErrorInfo()            # Stores error info for reporting.
        self.URL = url
        self.PostDict = post_data_dict
        self.HTML = ''
        self.Info = ''
        self.RequestTimeout = request_timeout

    def reset(self):
        self.ErrorInfo = None
        self.URL = ''
        self.PostDict = {}
        self.HTML = ''
        self.Info = ''
        self.RequestTimeout = 4

    def http_request(self):
        """ Request via HTTP, sets HTTPRequest class attributes."""
        if not self.PostDict:
            # Build HTTP GET
            http_request = urllib2.Request(self.URL)
            http_request.add_header('Accept-Charset:', 'utf-8')
            http_request.add_header('Accept:', 'application/json')
            http_request.add_header('Connection:', 'keep-alive')
        else:
            # Build HTTP Post request.
            url_encoded = urllib.urlencode(self.PostDict)
            http_request = urllib2.Request(self.URL, url_encoded)
            http_request.add_header('Accept-Charset:', 'utf-8')
            # http_request.add_header('Content-Type:', 'application/x-www-form-urlencoded; charset=utf-8')
            http_request.add_header('Accept:', 'application/json')
            http_request.add_header('Connection:', 'keep-alive')

        try:
            # Request the URL.
            http_response = urllib2.urlopen(http_request, None, self.RequestTimeout)
            self.Info = http_response.info()
            self.HTML = http_response.read()
            http_response.close()  # best practice to close
            self.ErrorInfo.Err = False

        except URLError, e:
            if hasattr(e, 'reason'):
                # We failed to reach a server.
                self.ErrorInfo.ErrCodeOrReason = e.reason
                if hasattr(e, 'read'):
                    self.ErrorInfo.ErrMessage = e.read()
                self.ErrorInfo.Err = True

            elif hasattr(e, 'code'):
                # The server could not fulfill the request.
                self.ErrorInfo.ErrCodeOrReason = e.code
                if hasattr(e, 'read'):
                    self.ErrorInfo.ErrMessage = e.read()
                self.ErrorInfo.Err = True

        return self

class RecordingRule:
    def __init__(self):
        self.ErrorInfo = ErrorInfo()            # Stores error info for reporting.
        self.__total_available = 1              # Myth total records for loading lists reporting.
        self.__load_count = 0                   # Counter for schedules list loading reporting.
        self.__list_index = 0                   # Index of currently returned list info.
        self.__recording_rule_dict = {}         # Dict of recording rules includes added recording filter info.

        global _list_index_to_rec_rule_id       # Mapping of UI list index to recording rule id.
        _list_index_to_rec_rule_id = {}

        global _program_overrides               # Add when a rec type 8 (Don' Record) is found for programs to resolve.
        _program_overrides = []

    def reset(self):
        self.ErrorInfo.reset()
        self.__total_available = 1
        self.__load_count = 0
        self.__list_index = 0
        self.__recording_rule_dict = {}

        global _list_index_to_rec_rule_id
        _list_index_to_rec_rule_id = {}

        global _program_overrides
        _program_overrides = []

    def get_schedules(self):
        """ Request a recording all schedules from Myth and set RecordingRule attributes."""
        # Clear all previous data.
        self.reset()

        # http request schedules per index & record count.
        class_http_requested = self.__request_schedules()

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)

        return class_http_requested.ErrorInfo

    def __request_schedules(self):
        """ Query the Myth backend for a recording schedule."""
        schedules_index = 0
        global _request_size
        class_http_request = HTTPRequest('')

        while schedules_index < self.__total_available:
            # Set URL String.
            http_url = _myth_url_prefix + '/Dvr/GetRecordScheduleList?StartIndex='\
                                        + str(schedules_index) + '&Count=' + str(_request_size)

            # Request schedules per index & record count, and verify request ok.
            class_http_request = HTTPRequest(http_url)
            class_http_requested = class_http_request.http_request()

            if class_http_requested.ErrorInfo.Err:
                # Notify error.
                return class_http_requested
            else:
                class_err_info = self.__json_to_schedule_list(class_http_requested.HTML)
                if class_err_info.Err:
                    class_http_requested.ErrorInfo.Err = True
                    class_http_requested.ErrorInfo.ErrCodeOrReason = class_err_info.ErrCodeOrReason
                    class_http_requested.ErrorInfo.ErrMessage = class_err_info.ErrMessage
                    return class_http_requested
                schedules_index += _request_size
        return class_http_request

    def __json_to_schedule_list(self, json_reply):
        """ Build list recording rule of dicts - Filter override rules and the recording template."""
        class_err_info = ErrorInfo()
        global _program_overrides

        try:
            RecRuleList = json.loads(json_reply)
            self.__total_available = int(RecRuleList['RecRuleList']['TotalAvailable'])
            if self.__total_available <= 1:
                self.schedules_list({}, 0)
                return class_err_info

            RecRules = RecRuleList['RecRuleList']['RecRules']

            for RecRule in RecRules:
                RecRule_Title = RecRule['Title']
                RecRule_Type = RecRule['Type']
                # RecRule_Description = RecRule['Description']
                RecRule_Id = RecRule['Id']
                RecRule_ChanId = RecRule['ChanId']
                RecRule_StartTime = RecRule['StartTime']
                RecRule_ParentId = RecRule['ParentId']

                if RecRule_Type != 'Not Recording':
                    if RecRule_Type != 'Override Recording':
                        # Record a mapping of list index to recording rule id for UI list.
                        _list_index_to_rec_rule_id[str(self.__list_index)] = RecRule_Id
                        # Add rule to UI list.
                        self.schedules_list(RecRule, self.__list_index)
                        self.__list_index += 1

                    # Record a list of program overrides used to match program list.
                    # For Myth PVR Schedules an override with a parent id is created.
                    # For MythWeb when selecting 'Dont Record' a rule is created as override, with no parent id.
                    elif RecRule_Type == 'Override Recording':
                        _program_overrides.append(RecRule_ChanId + ']' + RecRule_StartTime)
                        _program_overrides.append(RecRule_ParentId)

                        # If a MythWeb override (no parent id) add it as a separate recording rule.
                        if RecRule_ParentId == '0':
                            # Edit title to advise this is a MythWeb override.
                            RecRule['Title'] = 'MythWeb: ' + RecRule_Title + "  " + RecRule_Type
                            _list_index_to_rec_rule_id[str(self.__list_index)] = RecRule_Id
                            self.schedules_list(RecRule, self.__list_index)
                            self.__list_index += 1

                    # Report load status.
                    self.__load_count += 1
                    self.status(str(self.__load_count) + ' / ' + str(self.__total_available - 1))

        except ValueError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'ValueError'
            class_err_info.ErrMessage = 'Value Error'

        except KeyError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'KeyError'
            class_err_info.ErrMessage = 'Key Error'

        return class_err_info

    def schedules_list(self, rec_rule_dict, ui_list_index):
        """ Recording Schedules.  List of Dicts - Override me."""
        pass

    def get_schedule_rule(self, ui_list_index):
        """ Returns a specific recording rule."""
        global _list_index_to_rec_rule_id

        # Clear any previous http error info.
        self.ErrorInfo.reset()
        self.__recording_rule_dict = {}

        # Get mapping of list index to recording rule id.
        recording_rule_id = _list_index_to_rec_rule_id[str(ui_list_index)]

        # Http request schedule per rule Id.
        class_http_requested = self.__request_schedule(recording_rule_id)

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)
        else:
            self.schedule_rule(self.__recording_rule_dict)

        return class_http_requested.ErrorInfo

    def __request_schedule(self, recording_rule_id):
        """ Query the Myth backend for a specific recording schedule."""
        # Set URL String.
        http_url = _myth_url_prefix + '/Dvr/GetRecordSchedule?RecordId=' + str(recording_rule_id)

        # Request specific schedule, and verify request ok.
        class_http_request = HTTPRequest(http_url)
        class_http_requested = class_http_request.http_request()

        if class_http_requested.ErrorInfo.Err:
            # Notify error.
            return class_http_requested
        else:
            class_err_info = self.__json_to_schedule_rule(class_http_requested.HTML)
            if class_err_info.Err:
                class_http_requested.ErrorInfo.Err = True
                class_http_requested.ErrorInfo.ErrCodeOrReason = class_err_info.ErrCodeOrReason
                class_http_requested.ErrorInfo.ErrMessage = class_err_info.ErrMessage
                return class_http_requested
        return class_http_requested

    def __json_to_schedule_rule(self, json_html):
        """ Query the Myth backend for a specific recording schedule."""
        class_err_info = ErrorInfo()

        try:
            # Decode json.
            rec_rule_dict = json.loads(json_html)

            # Get the recording rule as a dictionary.
            schedule_dict = rec_rule_dict['RecRule']

            # Decode 'Filter' to add filter as dict items for UI edit. - Later re-encoded to 'Filter' & removed.
            recording_filter = schedule_dict['Filter']

            # Get filters as dict.
            recording_filters_dict = self.__recording_filter_to_dict(recording_filter)

            # Add filters dict to returned recording rule dict.
            schedule_dict.update(recording_filters_dict)

            self.__recording_rule_dict = schedule_dict

        except ValueError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'ValueError'
            class_err_info.ErrMessage = 'Value Error'

        except KeyError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'KeyError'
            class_err_info.ErrMessage = 'Key Error'
        return class_err_info

    def schedule_rule(self, rule_dict):
        """ Recording Rule Dict. - Override me."""
        pass

    def __recording_filter_to_dict(self, bcd_string):
        """ Return a dict of filter settings."""
        filter_bcd_int = int(bcd_string)
        filter_dict = {'FilterThisChannel': False, 'FilterThisDayAndTime': False, 'FilterThisTime': False,
                       'FilterThisSeries': False, 'FilterThisEpisode': False, 'FilterHighDefinition': False,
                       'FilterCommercialFree': False, 'FilterPrimeTime': False, 'FilterFirstShowing': False,
                       'FilterIdentifiableEpisode': False, 'FilterNewEpisode': False}

        if filter_bcd_int >= 1024:
            filter_dict['FilterThisChannel'] = True
            filter_bcd_int -= 1024

        if filter_bcd_int >= 512:
            filter_dict['FilterThisDayAndTime'] = True
            filter_bcd_int -= 512

        if filter_bcd_int >= 256:
            filter_dict['FilterThisTime'] = True
            filter_bcd_int -= 256

        if filter_bcd_int >= 128:
            filter_dict['FilterThisSeries'] = True
            filter_bcd_int -= 128

        if filter_bcd_int >= 64:
            filter_dict['FilterThisEpisode'] = True
            filter_bcd_int -= 64

        if filter_bcd_int >= 32:
            filter_dict['FilterHighDefinition'] = True
            filter_bcd_int -= 32

        if filter_bcd_int >= 16:
            filter_dict['FilterCommercialFree'] = True
            filter_bcd_int -= 16

        if filter_bcd_int >= 8:
            filter_dict['FilterPrimeTime'] = True
            filter_bcd_int -= 8

        if filter_bcd_int >= 4:
            filter_dict['FilterFirstShowing'] = True
            filter_bcd_int -= 4

        if filter_bcd_int >= 2:
            filter_dict['FilterIdentifiableEpisode'] = True
            filter_bcd_int -= 2

        if filter_bcd_int == 1:
            filter_dict['FilterNewEpisode'] = True

        return filter_dict

    def set_schedule_rule(self, recording_rule_dict):
        """ Edits a specific recording rule.."""
        # Clear any previous http error data.
        self.ErrorInfo.reset()

        # Return the recording rule dict with 'Filter set to encoded string int of added filter settings.
        recording_rule_dict = self.__recording_filter_from_dict(recording_rule_dict)

        # Preserve the current rule including added Filters for further edits.
        # Copy the rule and modify for posting to Myth. - Translate and remove added filter items.
        recording_rule_post_dict = dict(recording_rule_dict)

        # Translate for update.
        recording_rule_post_dict['RecordId'] = recording_rule_post_dict.pop('Id')
        recording_rule_post_dict['Station'] = recording_rule_post_dict.pop('CallSign')

        # Remove superfluous information.
        del recording_rule_post_dict['NextRecording']
        del recording_rule_post_dict['LastRecorded']
        del recording_rule_post_dict['LastDeleted']
        del recording_rule_post_dict['AverageDelay']

        # Remove decoded filter dict items from recording rule.
        del recording_rule_post_dict['FilterNewEpisode']
        del recording_rule_post_dict['FilterIdentifiableEpisode']
        del recording_rule_post_dict['FilterFirstShowing']
        del recording_rule_post_dict['FilterPrimeTime']
        del recording_rule_post_dict['FilterCommercialFree']
        del recording_rule_post_dict['FilterHighDefinition']
        del recording_rule_post_dict['FilterThisEpisode']
        del recording_rule_post_dict['FilterThisSeries']
        del recording_rule_post_dict['FilterThisTime']
        del recording_rule_post_dict['FilterThisDayAndTime']
        del recording_rule_post_dict['FilterThisChannel']

        # Request Myth rule update.
        class_http_requested = self.__update_recording_rule(recording_rule_post_dict)

        # Report http post error.
        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)

        # Report if Myth server did not respond ok with '{"bool": "true"}'
        if 'true' not in class_http_requested.HTML:
            class_http_requested.ErrorInfo.Err = True
            class_http_requested.ErrorInfo.ErrCodeOrReason = ''
            class_http_requested.ErrorInfo.ErrMessage = 'Myth server - Update Schedule: ' \
                                                        + str(class_http_requested.HTML)
            self.error(class_http_requested.ErrorInfo)

        return class_http_requested.ErrorInfo

    def __recording_filter_from_dict(self, recording_rule_dict):
        """ Return the recording rule dict with 'Filter set to encoded string int of filter settings."""
        # Encode Filters to BCD.
        filter_bcd_int = 0
        if recording_rule_dict['FilterNewEpisode']: filter_bcd_int = 1
        if recording_rule_dict['FilterIdentifiableEpisode']: filter_bcd_int += 2
        if recording_rule_dict['FilterFirstShowing']: filter_bcd_int += 4
        if recording_rule_dict['FilterPrimeTime']: filter_bcd_int += 8
        if recording_rule_dict['FilterCommercialFree']: filter_bcd_int += 16
        if recording_rule_dict['FilterHighDefinition']: filter_bcd_int += 32
        if recording_rule_dict['FilterThisEpisode']: filter_bcd_int += 64
        if recording_rule_dict['FilterThisSeries']: filter_bcd_int += 128
        if recording_rule_dict['FilterThisTime']: filter_bcd_int += 256
        if recording_rule_dict['FilterThisDayAndTime']: filter_bcd_int += 512
        if recording_rule_dict['FilterThisChannel']: filter_bcd_int += 1024
        recording_rule_dict['Filter'] = str(filter_bcd_int)
        return recording_rule_dict

    def __update_recording_rule(self, recording_rule_dict):
        """ HTTP POST recording rule data as dictionary."""
        http_url = _myth_url_prefix + '/Dvr/UpdateRecordSchedule'
        class_http_request = HTTPRequest(http_url, recording_rule_dict)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def remove_schedule(self, ui_list_index):
        """ Delete a specific recording rule."""
        # Clear any previous http error data.
        self.ErrorInfo.reset()

        # Get mapping of list index to recording rule id.
        recording_rule_id = _list_index_to_rec_rule_id[str(ui_list_index)]

        # Request recording rule deletion.
        schedule_id_dict = {'RecordId': str(recording_rule_id)}
        class_http_requested = self.__remove_recording_rule(schedule_id_dict)

        # Report http post error.
        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)

        # Report if Myth server did not respond ok with '{"bool": "true"}'
        if 'true' not in class_http_requested.HTML:
            class_http_requested.ErrorInfo.Err = True
            class_http_requested.ErrorInfo.ErrCodeOrReason = ''
            class_http_requested.ErrorInfo.ErrMessage = 'Myth server - Remove schedule: ' \
                                                        + str(class_http_requested.HTML)
            self.error(class_http_requested.ErrorInfo)

        return class_http_requested.ErrorInfo

    def __remove_recording_rule(self, schedule_id_dict):
        """ HTTP POST recording rule Id to be deleted as dictionary."""
        http_url = _myth_url_prefix + '/Dvr/RemoveRecordSchedule'
        # Init the HTTPRequest class with info.
        class_http_request = HTTPRequest(http_url, schedule_id_dict)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def get_recording_groups(self):
        """ Returns a list of Myth Backend recording groups."""
        # http request schedule per rule Id.
        class_http_requested = self.__request_recording_groups()

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)
            return []
        else:
            convert_to_dict = json.loads(class_http_requested.HTML)
            rec_group_list = convert_to_dict['StringList']
            return rec_group_list

    def __request_recording_groups(self):
        """ Http request a list of Myth Backend recording groups."""
        # Set URL String.
        http_url = _myth_url_prefix + '/Dvr/GetRecGroupList'
        class_http_request = HTTPRequest(http_url)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def storage_groups(self):
        """ Returns a list of Myth Backend storage groups."""

        class_http_requested = self.__request_storage_groups()

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)
            return []
        else:
            group_list = []
            convert_to_dict = json.loads(class_http_requested.HTML)
            storage_group_dir_list_dict = convert_to_dict['StorageGroupDirList']
            storage_group_dirs_dict = storage_group_dir_list_dict['StorageGroupDirs']

            for item in storage_group_dirs_dict:
                group_name = item['GroupName']
                # Filter out n/a groups.
                if (group_name != 'Banners') and (group_name != 'Coverart') and (group_name != 'DB Backups') \
                        and (group_name != 'Fanart') and (group_name != 'Screenshots') and (group_name != 'Streaming'):
                    group_list.append(group_name)
            return group_list

    def __request_storage_groups(self):
        """ Http request a list of Myth Backend storage groups."""
        # Set URL String.
        http_url = _myth_url_prefix + '/Myth/GetStorageGroupDirs'
        class_http_request = HTTPRequest(http_url)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def status(self, status_string):
        """ Status info for UI (Programs load x/x). - Override me."""
        pass

    def error(self, class_error_info):
        """ Error info. - Override me."""
        pass

class Programs:
    def __init__(self):
        self.ErrorInfo = ErrorInfo()              # Stores error info for reporting.
        self.__program_list = []                  # Cached programs list.
        self.__total_available = 1                # Myth total records for loading reporting.
        self.__load_count = 0                     # Counter for programs loading reporting.
        self.__program_index = 0                  # Index of program in the list of dicts.
        self.__program_per_list_index = []        # Current selected recording rule program list.

    def reset(self):
        self.ErrorInfo.reset()
        self.__program_list = []
        self.__total_available = 1
        self.__load_count = 0
        self.__program_index = 0

    def cache_programs_list(self):
        """ Build a list of all programs in RAM for quickly referring to during recording schedule focus."""
        # Clear any previous data.
        self.reset()

        # Http request programs per index & chunk size.
        class_http_requested = self.__request_programs()

        # Testing only.
        # parsed = json.loads(class_http_requested.HTML)
        # print json.dumps(parsed, indent=4, sort_keys=False)

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)

        return class_http_requested.ErrorInfo

    def __request_programs(self):
        """ Query the Myth backend for all programs in chunks."""
        programs_index = 0
        class_http_request = HTTPRequest('')
        global _request_size

        while programs_index <= self.__total_available:
            # Set URL String.
            http_url = _myth_url_prefix + '/Dvr/GetUpcomingList?' \
                                        + 'StartIndex=' + str(programs_index) \
                                        + '&Count=' + str(_request_size) \
                                        + '&ShowAll=true'

            # Request programs per index & record count, and verify request ok.
            class_http_request = HTTPRequest(http_url)
            class_http_requested = class_http_request.http_request()

            if class_http_requested.ErrorInfo.Err:
                # Notify error.
                return class_http_requested

            else:
                class_err_info = self.__json_to_program_list(class_http_requested.HTML)
                if class_err_info.Err:
                    class_http_requested.ErrorInfo.Err = True
                    class_http_requested.ErrorInfo.ErrCodeOrReason = class_err_info.ErrCodeOrReason
                    class_http_requested.ErrorInfo.ErrMessage = class_err_info.ErrMessage
                    return class_http_requested
            programs_index += _request_size
        return class_http_request

    def __json_to_program_list(self, json_reply):
        """ Build list of dicts - Filter out programs."""
        class_err_info = ErrorInfo()
        global _date_format
        global _time_format

        try:
            program_list = json.loads(json_reply)
            self.__total_available = int(program_list['ProgramList']['TotalAvailable'])
            programs = program_list['ProgramList']['Programs']

            for program in programs:
                program_RecordId = program['Recording']['RecordId']
                program_StartTime = program['StartTime']
                program_EndTime = program['EndTime']
                program_ProgramId = program['ProgramId']
                program_Description = program['Description']
                program_ChanId = program['Channel']['ChanId']
                program_CallSign = program['Channel']['CallSign']
                program_Status = program['Recording']['Status']
                program_RecType = program['Recording']['RecType']

                # Decode status code.
                program_Status_str = self.__program_status_string(program_Status)

                # Decode Recording type code.
                # rec_type_str = self.__program_recording_type_string(prog_RecType)

                # Convert Myth utc time to local time and in user selected format.
                program_local_StartDate_str = _myth_utc_to_local_time(program_StartTime, _date_format)
                program_local_StartTime_str = _myth_utc_to_local_time(program_StartTime, _time_format)
                program_local_EndTime_str = _myth_utc_to_local_time(program_EndTime, _time_format)

                # Build program dictionary.
                program_dict = {'program_index': str(self.__program_index),
                                'RecordId': program_RecordId, 'RecType': program_RecType, 'ChanId': program_ChanId,
                                'StartTime': program_StartTime, 'EndTime': program_EndTime,
                                'StartDate_str': program_local_StartDate_str,
                                'StartTime_str': program_local_StartTime_str, 'EndTime_str': program_local_EndTime_str,
                                'Status': program_Status, 'Status_str': program_Status_str,
                                'CallSign': program_CallSign, 'ProgramId': program_ProgramId,
                                'Description': program_Description}

                self.__program_list.append(program_dict)
                self.__program_index += 1

                # Report load status.
                self.__load_count += 1
                self.status(str(self.__load_count) + ' / ' + str(self.__total_available))

        except ValueError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'ValueError'
            class_err_info.ErrMessage = 'Value Error'

        except KeyError:
            class_err_info.Err = True
            class_err_info.ErrCodeOrReason = 'KeyError'
            class_err_info.ErrMessage = 'Key Error'

        return class_err_info

    def get_programs(self, ui_list_index):
        """ Programs. List of Dicts per schedule id."""
        global _list_index_to_rec_rule_id
        global _program_overrides
        self.__program_per_list_index = []
        list_index = 0
        found_program = False

        # Get mapping of list index to recording rule id.
        schedule_id = _list_index_to_rec_rule_id[str(ui_list_index)]

        programs = (element for element in self.__program_list)

        for program in programs:
            # List programs per recording rule ID, includes MythWeb program status 'Don't record'.
            if program["RecordId"] == schedule_id:
                found_program = True

                # Store for quick lookup of program description, series info etc.
                self.__program_per_list_index.append(program)

                # Provide program info dict to UI.
                self.programs_list(program, list_index)
                list_index += 1

            # Myth PVR Schedules override recordings.
            elif program["RecType"] == '8':
                # Search the list of overrides (Dont Record) to match Channel id and start time.
                program_ChanId = program['ChanId']
                program_StartTime = program['StartTime']
                query = program_ChanId + ']' + program_StartTime

                if query in _program_overrides:
                    # Matched a program override with recording rule based on Channel ID + Start time.
                    idx = _program_overrides.index(query)
                    parent_rec_rule_id = _program_overrides[idx + 1]         # Parent rule id

                    # If this override parent id matches the currently selected recording schedule - Add to list.
                    if parent_rec_rule_id == schedule_id:
                        found_program = True

                        # Store for quick lookup of program description, series info etc.
                        self.__program_per_list_index.append(program)

                        # Provide program info dict to UI.
                        self.programs_list(program, list_index)
                        list_index += 1

        if not found_program:
            self.programs_list({}, 0)

    def get_program_per_list_index(self, ui_list_index):
        """ Returns a program series info for a program given an index of listed program."""
        list_index_int = int(ui_list_index)
        if list_index_int <= len(self.__program_per_list_index) - 1:
            return self.__program_per_list_index[list_index_int]

    def toggle_override(self, ui_list_index):
        """ Disable or enable a program recording."""
        class_http_requested = HTTPRequest('')

        list_index_int = int(ui_list_index)
        program_and_list_index = self.__program_per_list_index[list_index_int]["program_index"]

        #  Get the referenced program from the cashed list item and edit to create/delete override 'Don't Record'.
        programs = (program for program in self.__program_list
                    if program["program_index"] == program_and_list_index)

        for program in programs:
            program_RecType = program['RecType']
            program_ChanId = program['ChanId']
            program_StartTime = program['StartTime']
            program_RecordId = program['RecordId']

            # If not already an override (Don't Record), create one.
            if program_RecType != '8':
                # Get an override rule template for this program.
                # A recording override template is requested using channel id & start time.
                # The recording rule is set to type 'Don't record' and HTTP Posted back.
                # A new recording rule is created with type 'Override Recording' and a parent id.
                # A corresponding program will be set with RecType 8 - 'Don't record'
                class_http_requested = self.__request__override_template(program_ChanId, program_StartTime)

                if class_http_requested.ErrorInfo.Err:
                    return class_http_requested.ErrorInfo
                else:
                    rec_rule_dict = json.loads(class_http_requested.HTML)
                    template_dict = rec_rule_dict['RecRule']

                    # Translate for update.
                    # template_dict['RecordId'] = template_dict.pop('Id')
                    template_dict['Station'] = template_dict.pop('CallSign')

                    # Set Don't record.
                    template_dict['Type'] = 'Dont Record'
                    template_dict['SearchType'] = 'None'
                    template_dict['SubTitle'] = program_StartTime

                    # Http post the rule to Myth back end.
                    # If updated ok, reflect the change in the listed program.
                    class_http_requested = self.__request_override(template_dict)
                    if class_http_requested.ErrorInfo.Err:
                        return class_http_requested.ErrorInfo
                    else:
                        # Return html reply via ErrorInfo.ErrMessage for logging the new recording rule for log.
                        class_http_requested.ErrorInfo.ErrMessage = class_http_requested.HTML

                    # Report if Myth server did not respond ok with 'uint'  E.g.: {"uint": "252"}'
                    if 'uint' not in class_http_requested.HTML:
                        class_http_requested.ErrorInfo.Err = True
                        class_http_requested.ErrorInfo.ErrCodeOrReason = ''
                        class_http_requested.ErrorInfo.ErrMessage = 'Myth server - Add override: ' \
                                                                    + str(class_http_requested.HTML)
                        self.error(class_http_requested.ErrorInfo)
                        return class_http_requested.ErrorInfo
                    else:
                        # Update the global override list '_program_overrides' (Normally generated from schedule list)
                        global _program_overrides
                        _program_overrides.append(program_ChanId + ']' + program_StartTime)
                        _program_overrides.append(program_RecordId)

                        # Update program cache list 'self.__program_list'
                        decoded_json = json.loads(class_http_requested.HTML)
                        override_rec_rule_id = decoded_json['uint']
                        program['RecordId'] = override_rec_rule_id
                        program['RecType'] = '8'
                        program['Status'] = '1'
                        program['Status_str'] = 'Dont Record'

            elif program_RecType == '8':
                    # Delete the override recording rule.
                    # Clear any http error data.
                    self.ErrorInfo.reset()

                    # Request recording rule deletion.
                    schedule_id_dict = {'RecordId': str(program_RecordId)}
                    class_http_requested = self.__remove_recording_rule(schedule_id_dict)

                    # Report http post error.
                    if class_http_requested.ErrorInfo.Err:
                        self.error(class_http_requested.ErrorInfo)
                        return class_http_requested.ErrorInfo

                    # Report if Myth server did not respond ok with '{"bool": "true"}'
                    if 'true' not in class_http_requested.HTML:
                        class_http_requested.ErrorInfo.Err = True
                        class_http_requested.ErrorInfo.ErrCodeOrReason = ''
                        class_http_requested.ErrorInfo.ErrMessage = 'Myth server - Remove schedule: ' \
                                                                    + str(class_http_requested.HTML)
                        self.error(class_http_requested.ErrorInfo)
                        return class_http_requested.ErrorInfo
                    else:
                        # Update the global override list '_program_overrides' (Normally generated from schedule list)
                        global _program_overrides
                        # Search the list of overrides (Dont Record) to match Channel id and start time.
                        program_ChanId = program['ChanId']
                        program_StartTime = program['StartTime']
                        query = program_ChanId + ']' + program_StartTime

                        if query in _program_overrides:
                            # Matched a program override with recording rule based on Channel ID + Start time.
                            idx = _program_overrides.index(query)

                            # Update program cache list 'self.__program_list'
                            program['RecordId'] = _program_overrides.pop(idx + 1)
                            program['RecType'] = '4'
                            program['Status'] = '-1'
                            program['Status_str'] = 'Will Record'

                            # Remove from override list.
                            _program_overrides.pop(idx)

        return class_http_requested.ErrorInfo

    def __request__override_template(self, rec_channel_id, rec_start_time):
        """ Http request the Myth backend for a recording schedule."""
        self.ErrorInfo.reset()
        # Set URL String.
        http_url = _myth_url_prefix + '/Dvr/GetRecordSchedule?' \
                                    + 'ChanId=' + rec_channel_id \
                                    + '&StartTime=' + rec_start_time \
                                    + '&MakeOverride=true'
        # Request override rule and verify http get ok.
        class_http_request = HTTPRequest(http_url)
        class_http_requested = class_http_request.http_request()

        if class_http_requested.ErrorInfo.Err:
            self.error(class_http_requested.ErrorInfo)
        return class_http_requested

    def __request_override(self, recording_rule_dict):
        """ HTTP POST override rule data as dictionary."""
        http_url = _myth_url_prefix + '/Dvr/AddRecordSchedule'
        class_http_request = HTTPRequest(http_url, recording_rule_dict)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def __remove_recording_rule(self, schedule_id_dict):
        """ HTTP POST recording rule Id to be deleted as dictionary."""
        http_url = _myth_url_prefix + '/Dvr/RemoveRecordSchedule'
        # Init the HTTPRequest class with info.
        class_http_request = HTTPRequest(http_url, schedule_id_dict)
        class_http_requested = class_http_request.http_request()
        return class_http_requested

    def programs_list(self, program_dict, ui_list_index):
        """ Programs per Record Id, given list index - Override me."""
        pass

    def status(self, status_string):
        """ Status info for UI (Programs load x/x). - Override me."""
        pass

    def error(self, class_error_info):
        """ Error info. - Override me."""
        pass

    def __program_status_string(self, str_code):
        """ Program status code to string."""
        # Info here: https://github.com/janbar/pvr.mythtv/blob/doityourself/lib/cppmyth/src/mythtypes.h
        # https://github.com/ascagnel/mythPlex/blob/master/mythPlex.py
        # https://github.com/janbar/pvr.mythtv
        if str_code == '-10':
            return 'Tuning'
        elif str_code == '-9':
            return 'Failed'
        elif str_code == '-8':
            return 'Tuner Busy'
        elif str_code == '-7':
            return 'Low Diskspace'
        elif str_code == '-6':
            return 'Canceled'
        elif str_code == '-5':
            return 'Missed'
        elif str_code == '-4':
            return 'Aborted'
        elif str_code == '-3':
            return 'Recorded'
        elif str_code == '-2':
            return 'Recording'
        elif str_code == '-1':
            return 'Will Record'
        elif str_code == '0':
            return 'Unknown'
        elif str_code == '1':
            return 'Dont Record'
        elif str_code == '2':
            return 'Previous Recording'
        elif str_code == '3':
            return 'Current Recording'
        elif str_code == '3':
            return 'Current Recording'
        elif str_code == '4':
            return 'Earlier Recording'
        elif str_code == '5':
            return 'Too Many Recordings'
        elif str_code == '6':
            return 'Not Listed'
        elif str_code == '7':
            return 'Conflict'
        elif str_code == '8':
            return 'Later Showing'
        elif str_code == '9':
            return 'Repeat'
        elif str_code == '10':
            return 'Inactive'
        elif str_code == '11':
            return 'Never Record'
        elif str_code == '12':
            return 'Offline'
        elif str_code == '13':
            return 'Other Showing'
        else:
            return 'None'

    def __program_recording_type_string(self, str_code):
        """ Program recording type code to string."""
        if str_code == '0':
            return 'Not Recording'
        elif str_code == '1':
            return 'Single Record'
        elif str_code == '2':
            return 'Daily Record'
        elif str_code == '3':  # obsolete since 76
            return 'Channel Record'
        elif str_code == '4':
            return 'All Record'
        elif str_code == '5':
            return 'Weekly Record'
        elif str_code == '6':
            return 'One Record'
        elif str_code == '7':
            return 'Override Record'
        elif str_code == '8':
            return 'Dont Record'
        elif str_code == '9':  # obsolete since 76
            return 'Find Daily Record'
        elif str_code == '10':  # obsolete since 76
            return 'Find Weekly Record'
        elif str_code == '11':
            return 'Template Record'
        else:
            return 'None'

def _myth_utc_to_local_time(myth_utc, time_date_format='?'):
    """ Returns a list of local date/time formats."""
    str_time = time.strptime(myth_utc, "%Y-%m-%dT%H:%M:%SZ")
    epoch = time.mktime(str_time)
    utc = datetime.fromtimestamp(epoch)
    offset = datetime.fromtimestamp(epoch) - datetime.utcfromtimestamp(epoch)
    local_time = str(utc + offset)  # 2015-04-13 18:30:00
    local_time_24hr = time.strptime(local_time, "%Y-%m-%d %H:%M:%S")

    # http://strftime.org/
    if time_date_format == '?':
        return time.strftime("%Z", local_time_24hr)             # AUS Eastern Daylight Time
    if time_date_format == 'Day':
        return time.strftime("%A", local_time_24hr)             # Tuesday
    elif time_date_format == '12Hr':
        return time.strftime("%I:%M%p", local_time_24hr)        # 06:45PM
    elif time_date_format == '24Hr':
        return time.strftime("%H:%M", local_time_24hr)          # 18:45
    elif time_date_format == 'DD-MM-YYYY':
        return time.strftime("%d-%m-%Y", local_time_24hr)       # 26-05-2015
    elif time_date_format == 'YYYY-MM-DD':
        return time.strftime("%Y-%m-%d", local_time_24hr)       # 2015-05-26
    elif time_date_format == 'MM-DD-YYYY':
        return time.strftime("%m-%d-%Y", local_time_24hr)       # 05-26-2015

def string_to_bool(true_or_false):
    """ Convert Myth http bool string to bool."""
    return 'true' in true_or_false.lower()
